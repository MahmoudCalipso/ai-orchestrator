"""
Universal Build System
Standardized build.sh and Makefile generation
"""
import logging
from typing import Dict, Any
from core.workbench.blueprint import BlueprintRegistry

logger = logging.getLogger(__name__)

class UniversalBuildSystem:
    """Generates standardized build scripts for any stack"""
    
    def __init__(self):
        self.blueprint_registry = BlueprintRegistry()
    
    def generate_build_script(self, stack: str, project_name: str) -> str:
        """Generate build.sh for any stack"""
        blueprint = self.blueprint_registry.get_blueprint(stack)
        if not blueprint:
            return self._default_build_script()
        
        return f"""#!/bin/bash
# Universal Build Script for {project_name}
# Stack: {stack}
# Generated by AI Orchestrator

set -e

echo "Building {project_name} ({stack})..."

# Install dependencies
{blueprint.build_command}

echo "Build complete!"
"""
    
    def generate_makefile(self, stack: str, project_name: str) -> str:
        """Generate Makefile for any stack"""
        blueprint = self.blueprint_registry.get_blueprint(stack)
        if not blueprint:
            return self._default_makefile()
        
        return f"""# Universal Makefile for {project_name}
# Stack: {stack}

.PHONY: install build run test clean

install:
\t{blueprint.package_manager} install || {blueprint.build_command.split()[0]} install

build:
\t{blueprint.build_command}

run:
\t{blueprint.run_command}

test:
\techo "Running tests..."
\t# Add test command based on stack

clean:
\techo "Cleaning build artifacts..."
\trm -rf target/ dist/ build/ node_modules/ __pycache__/

help:
\t@echo "Available targets:"
\t@echo "  install - Install dependencies"
\t@echo "  build   - Build the project"
\t@echo "  run     - Run the application"
\t@echo "  test    - Run tests"
\t@echo "  clean   - Clean build artifacts"
"""
    
    def _default_build_script(self) -> str:
        return """#!/bin/bash
echo "No build configuration available"
"""
    
    def _default_makefile(self) -> str:
        return """# Default Makefile
help:
\t@echo "No build configuration available"
"""

class PortForwardingManager:
    """Manages dynamic port forwarding for workbenches"""
    
    def __init__(self):
        self.port_mappings: Dict[str, Dict[str, Any]] = {}
        self.next_public_port = 8000
    
    async def create_tunnel(
        self,
        workbench_id: str,
        container_port: int,
        subdomain: str = None
    ) -> Dict[str, Any]:
        """Create a public tunnel to a container port"""
        # In production, this would integrate with ngrok, Cloudflare Tunnel, or custom reverse proxy
        
        public_port = self.next_public_port
        self.next_public_port += 1
        
        public_url = f"http://localhost:{public_port}"
        if subdomain:
            public_url = f"https://{subdomain}.paas.orchestrator.com"
        
        self.port_mappings[workbench_id] = {
            "container_port": container_port,
            "public_port": public_port,
            "public_url": public_url,
            "subdomain": subdomain
        }
        
        logger.info(f"Created tunnel for workbench {workbench_id}: {public_url} -> {container_port}")
        
        return {
            "workbench_id": workbench_id,
            "public_url": public_url,
            "container_port": container_port
        }
    
    async def close_tunnel(self, workbench_id: str):
        """Close a tunnel"""
        if workbench_id in self.port_mappings:
            del self.port_mappings[workbench_id]
            logger.info(f"Closed tunnel for workbench {workbench_id}")
    
    def get_tunnel(self, workbench_id: str) -> Dict[str, Any]:
        """Get tunnel information"""
        return self.port_mappings.get(workbench_id)
